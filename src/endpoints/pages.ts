import { OpenAPIRoute, Str, Num } from "chanfana";
import { z } from "zod";

// --- Base Schemas (derived from OpenAPI spec components) ---

// Placeholder ProblemDetails schema
const ProblemDetailsSchema = z.object({
  type: z.string().url().optional().describe("A URI reference [RFC3986] that identifies the problem type."),
  title: z.string().describe("A short, human-readable summary of the problem type."),
  status: z.number().int().describe("The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem."),
  detail: z.string().optional().describe("A human-readable explanation specific to this occurrence of the problem."),
  instance: z.string().url().optional().describe("A URI reference that identifies the specific occurrence of the problem."),
}).describe("Problem Details Schema (RFC 7807)");

// Placeholder Page schema based on example and common fields
const PageSchema = z.object({
    id: Str({ description: "Page identifier" }),
    versionInfo: z.object({
        label: Str({ description: "Version label"}),
        description: Str({ description: "Version description"}),
        created: z.object({
            at: Str({ description: "Creation timestamp" }),
            by: Str({ description: "Creator identifier" }),
        }),
    }).describe("Version Information"),
    siteId: Str({ description: "Identifier of the site this page belongs to" }),
    parentPageId: Str({ description: "Identifier of the parent page", required: false }),
    path: Str({ description: "URL path of the page" }),
    title: Str({ description: "Page title" }),
    name: Str({ description: "Page name (usually the last path segment)" }),
    description: Str({ description: "Page description", required: false }),
    // thumbnail, metadata, _links mentioned as not implemented in the spec description
}).describe("Page Resource");

// Placeholder Paginated Pages List schema
const PaginatedPagesListSchema = z.object({
  cursor: Str({ description: "Cursor for fetching the next page of results", required: false }),
  items: z.array(PageSchema).describe("List of Page resources"),
}).describe("Paginated list of Pages");


// --- /pages ---

export class PagesList extends OpenAPIRoute {
  schema = {
    tags: ["Pages"],
    summary: "List Pages",
    description: "Lists the Pages of a Site, or the children of a specific Page.",
    request: {
      query: z.object({
        parentPageId: Str({ description: "Filter by parent page identifier", required: false }),
        siteId: Str({ description: "Filter by site identifier", required: false }),
        cursor: Str({ description: "Pagination cursor", required: false }),
        limit: Num({
          description: "Maximum number of items per page",
          default: 50,
          required: false,
        }),
      }),
    },
    responses: {
      "200": {
        description: "OK",
        content: {
          "application/json": {
            schema: PaginatedPagesListSchema,
          },
        },
      },
       "400": {
         description: "Bad Request (e.g., invalid limit or cursor)",
         content: { "application/json": { schema: ProblemDetailsSchema } },
       },
    },
  };

  async handle(c: any) {
    const data = await this.getValidatedData<typeof this.schema>();
    console.log("Query Params:", data.query);
    // TODO: Implement actual logic to fetch pages based on query params
    return {
      cursor: "next-cursor-string", // Provide a cursor if more items exist
      items: [
        {
          id: "page-123",
          versionInfo: { label: "v1.0", description: "Initial version", created: { at: new Date().toISOString(), by: "admin" } },
          siteId: data.query?.siteId || "site-abc",
          parentPageId: data.query?.parentPageId,
          path: "/example/page",
          title: "Example Page",
          name: "page",
          description: "This is a sample page.",
        },
      ],
    };
  }
}

// --- /pages/:pageId ---

export class PagesFetchById extends OpenAPIRoute {
  schema = {
    tags: ["Pages"],
    summary: "Get a Page by ID",
    request: {
      params: z.object({
        pageId: Str({ description: "Page identifier" }),
      }),
    },
    responses: {
      "200": {
        description: "OK",
        content: {
          "application/json": {
            schema: PageSchema,
          },
        },
      },
      "404": {
        description: "Page not found",
        content: { "application/json": { schema: ProblemDetailsSchema } },
      },
    },
  };

  async handle(c: any) {
    const data = await this.getValidatedData<typeof this.schema>();
    const { pageId } = data.params;
    console.log("Page ID:", pageId);

    // TODO: Implement actual logic to fetch page by ID
    const pageExists = true; // Replace with actual check

    if (!pageExists) {
      return new Response(
        JSON.stringify({ title: "Not Found", status: 404, detail: `Page with ID ${pageId} not found.` }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }

    return {
      id: pageId,
      versionInfo: { label: "v1.1", description: "Updated version", created: { at: new Date().toISOString(), by: "editor" } },
      siteId: "site-abc",
      path: `/example/${pageId}`,
      title: `Page ${pageId}`,
      name: pageId,
      description: `Details for page ${pageId}.`,
    };
  }
}

// --- /pages/byUrl ---
// NOTE: This endpoint was not fully defined in the provided spec snippet.
// Assuming it takes a 'url' query parameter.

export class PagesFetchByUrl extends OpenAPIRoute {
  schema = {
    tags: ["Pages"],
    summary: "Get a Page by URL",
    description: "Retrieves a page resource based on its public URL.",
    request: {
       // Assuming a 'url' query parameter is needed. Adjust if different.
      query: z.object({
        url: Str({ description: "The full public URL of the page" }),
      }),
    },
    responses: {
      "200": {
        description: "OK",
        content: {
          "application/json": {
            schema: PageSchema,
          },
        },
      },
      "404": {
        description: "Page not found for the given URL",
        content: { "application/json": { schema: ProblemDetailsSchema } },
      },
    },
  };

  async handle(c: any) {
    const data = await this.getValidatedData<typeof this.schema>();
    const { url } = data.query;
    console.log("Page URL:", url);

    // TODO: Implement actual logic to fetch page by URL
    const pageExists = true; // Replace with actual check

    if (!pageExists) {
      return new Response(
        JSON.stringify({ title: "Not Found", status: 404, detail: `Page with URL ${url} not found.` }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Extract path or derive details from URL if needed for the response
    const path = new URL(url).pathname;
    const name = path.substring(path.lastIndexOf('/') + 1) || 'index';

    return {
      id: `page-for-${name}`,
      versionInfo: { label: "v1.0", description: "Live version", created: { at: new Date().toISOString(), by: "system" } },
      siteId: "site-abc",
      path: path,
      title: `Page for URL ${url}`,
      name: name,
      description: `Details for page at ${url}.`,
    };
  }
}


// --- /pages/:pageId/content ---

export class PagesContentById extends OpenAPIRoute {
  schema = {
    tags: ["Pages"],
    summary: "Get the Content of a Page",
    description: "Retrieves the JSON content structure of a specific page.",
    request: {
      params: z.object({
        pageId: Str({ description: "Page identifier" }),
      }),
    },
    responses: {
      "200": {
        description: "The content of the Page.",
        content: {
          // Using a generic object schema as defined in the spec
          "application/json": {
            schema: z.object({}).passthrough().describe("Arbitrary JSON content structure of the page"),
          },
        },
      },
      "404": {
        description: "Page not found",
        content: { "application/json": { schema: ProblemDetailsSchema } },
      },
    },
  };

  async handle(c: any) {
    const data = await this.getValidatedData<typeof this.schema>();
    const { pageId } = data.params;
    console.log("Page ID for Content:", pageId);

    // TODO: Implement actual logic to fetch page content by ID
    const pageExists = true; // Replace with actual check

    if (!pageExists) {
       return new Response(
        JSON.stringify({ title: "Not Found", status: 404, detail: `Content for page ID ${pageId} not found.` }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Return example JSON content
    return {
      "jcr:primaryType": "cq:PageContent",
      "jcr:title": `Content for Page ${pageId}`,
      "sling:resourceType": "core/components/page",
      "root": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "core/components/container",
        "layout": "responsiveGrid",
        "container": {
           "jcr:primaryType": "nt:unstructured",
           "sling:resourceType": "core/components/container",
           "text": {
               "jcr:primaryType": "nt:unstructured",
               "sling:resourceType": "core/components/text",
               "text": `<p>This is the example content for page ${pageId}.</p>`,
           }
        }
      }
    };
  }
} 